
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<link rel="manifest" href="/manifest.json">
<title>FriendChess</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<style>
body { background:#222; color:white; font-family:sans-serif; text-align:center; }
.board { display:grid; grid-template-columns:repeat(8,60px); width:480px; margin:20px auto; }
.square { width:60px; height:60px; display:flex; align-items:center; justify-content:center;
          font-size:34px; cursor:pointer; }
.white { background:#eee; color:black; }
.black { background:#555; }
.selected { outline:3px solid red; }

.own { color:#00ff88; }
.enemy { color:#ff5555; }

.chat { width:480px; margin:auto; border:1px solid #555; padding:5px; }
.chatlog { height:140px; overflow-y:auto; text-align:left; font-size:14px; }

#turn { font-weight:bold; margin:10px; font-size:18px; }
.highlight { outline:3px solid yellow; }
</style>
</head>

<body>
<h1>FriendChess</h1>
<p id="info">Verbindeâ€¦</p>
<p id="turn">Am Zug: â€¦</p>

<div class="board" id="board"></div>

<div class="chat">
    <div class="chatlog" id="chatlog"></div>
    <input id="chatinput" placeholder="Nachrichtâ€¦" />
    <button onclick="sendChat()">Senden</button>
</div>

<script>
const socket = io();
const moveSound = new Audio("/sounds/ficha-de-ajedrez-34722.mp3");
const boardDiv = document.getElementById("board");
const chatlog = document.getElementById("chatlog");
const info = document.getElementById("info");
const turnDisplay = document.getElementById("turn");

let selected = null;
let state = {};          // Keys sind jetzt UCI-Squares wie "e2"
let playerColor = null;
let lastMove = null;

// ğŸ”¥ EJS statt Flask
const room_id = "<%= room_id %>";

// Dein ursprÃ¼ngliches Layout (weiÃŸe Figuren oben)
const pieces = [
 ["â™–","â™˜","â™—","â™•","â™”","â™—","â™˜","â™–"],
 ["â™™","â™™","â™™","â™™","â™™","â™™","â™™","â™™"],
 ["","","","","","","",""],
 ["","","","","","","",""],
 ["","","","","","","",""],
 ["","","","","","","",""],
 ["â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ","â™Ÿ"],
 ["â™œ","â™","â™","â™›","â™š","â™","â™","â™œ"]
];

// Initialisiere state mit UCI-Squares (a1â€“h8)
function initBoard(){
    state = {};
    for(let y = 0; y < 8; y++){
        for(let x = 0; x < 8; x++){
            const piece = pieces[y][x];
            if(!piece) continue;

            const file = String.fromCharCode("a".charCodeAt(0) + x); // aâ€“h
            const rank = 8 - y;                                     // y=0 â†’ 8, y=7 â†’ 1
            const square = file + rank;                             // z.B. "e2"

            state[square] = piece;
        }
    }
}
initBoard();

// Zeichnet das Brett, rotiert je nach Spielerfarbe, aber state bleibt immer UCI-basiert
function draw(){
    boardDiv.innerHTML = "";

    const filesWhite = ["a","b","c","d","e","f","g","h"];
    const filesBlack = [...filesWhite].reverse();
    const ranksWhite = [8,7,6,5,4,3,2,1];
    const ranksBlack = [...ranksWhite].reverse();

    const files = playerColor === "black" ? filesBlack : filesWhite;
    const ranks = playerColor === "black" ? ranksBlack : ranksWhite;

    for (let r of ranks) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
            const f = files[fIndex];
            const square = f + r; // UCI-Key, z.B. "e2"

            const sq = document.createElement("div");

            // Farbgebung nach Datei/Rank-Index (0â€“7)
            const fileIndex = f.charCodeAt(0) - "a".charCodeAt(0);
            const rankIndex = r - 1;
            sq.className = "square " + ((fileIndex + rankIndex) % 2 ? "black" : "white");

            if (square === selected) sq.classList.add("selected");

            if (lastMove && (square === lastMove.from || square === lastMove.to)) {
                sq.classList.add("highlight");
            }

            const piece = state[square] || "";
            sq.textContent = piece;

            if (piece) {
                const isWhite = "â™™â™–â™˜â™—â™•â™”".includes(piece);
                const own = (playerColor === "white" && isWhite) ||
                            (playerColor === "black" && !isWhite);
                sq.classList.add(own ? "own" : "enemy");
            }

            sq.onclick = () => clickSquare(square);
            boardDiv.appendChild(sq);
        }
    }
}

// Hier werden direkt UCI-Squares (z.B. "e2") verwendet
function clickSquare(square){
    if (!playerColor) return;

    if (selected) {
        const from = selected;
        const to = square;

        if (from !== to) {
            socket.emit("move", {
                from: from,   // z.B. "e2"
                to: to,       // z.B. "e4"
                room: room_id
            });
        }
        selected = null;
    } else if (state[square]) {
        selected = square;
    }
    draw();
}

function sendChat(){
    const i = document.getElementById("chatinput");
    if(i.value.trim()){
        socket.emit("chat",{msg:i.value,room:room_id});
        i.value="";
    }
}

socket.emit("join",{room:room_id});

socket.on("player", d => {
    playerColor = d.color;
    info.textContent = "Du bist " + playerColor;
    draw();
});

socket.on("move", d => {
    // d.from und d.to sind UCI-Squares, z.B. "e2", "e4"
    if (d.promotion) {
        state[d.to] = d.promotion;
    } else {
        state[d.to] = state[d.from];
    }
    delete state[d.from];

    lastMove = d.last_move; // sollte ebenfalls {from:"e2", to:"e4"} im UCI-Format sein
    turnDisplay.textContent = "Am Zug: " + d.next_turn;

    moveSound.currentTime = 0;
    moveSound.play();

    draw();
});

socket.on("chat", m => {
    chatlog.innerHTML += m + "<br>";
    chatlog.scrollTop = chatlog.scrollHeight;
});

socket.on("full", () => info.textContent = "Spiel ist voll!");

draw();
</script>
<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/service-worker.js");
  }
</script>

</body>
</html>
